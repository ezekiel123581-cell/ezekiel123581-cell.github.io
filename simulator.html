<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>시각 예술 구성/제작순서 시뮬레이터 - three.js (r147)</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 280px 1fr 320px; grid-template-rows: 48px 1fr; height: 100vh; }
    header { grid-column: 1 / 4; display: flex; align-items: center; gap: 12px; padding: 8px 12px; border-bottom: 1px solid #e5e7eb; background: #fafafa; }
    header h1 { font-size: 16px; margin: 0; font-weight: 700; }
    .pill { padding: 4px 10px; border: 1px solid #e5e7eb; border-radius: 999px; background: #fff; font-size: 12px; }
    aside { border-right: 1px solid #e5e7eb; overflow: auto; }
    .right { border-left: 1px solid #e5e7eb; overflow: auto; }
    .panel { padding: 12px; }
    .panel h2 { font-size: 13px; margin: 10px 0; color: #111827; }
    .btn { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; background: white; cursor: pointer; font-size: 12px; }
    .btn:active { transform: translateY(1px); }
    .btn + .btn { margin-left: 6px; }
    .stack { display: flex; flex-direction: column; gap: 8px; }
    .row { display: flex; gap: 6px; flex-wrap: wrap; }
    .muted { color: #6b7280; font-size: 12px; }
    .list { display: grid; gap: 8px; }
    .item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; display: grid; grid-template-columns: 1fr auto; align-items: center; background: #fff; }
    .item .title { font-size: 13px; font-weight: 600; }
    .item .sub { font-size: 11px; color: #6b7280; }
    .ghost { opacity: .5; }
    #viewport { position: relative; background: #f8fafc; height: 100%; }
    #canvasWrap { width: 100%; height: 100%; position: absolute; inset: 0; }
    .tip { background: #f1f5f9; border: 1px dashed #cbd5e1; padding: 8px; border-radius: 8px; font-size: 12px; line-height: 1.4; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 0 6px; border: 1px solid #e5e7eb; border-bottom-width: 2px; border-radius: 6px; background: #fff; }
    .danger { color: #b91c1c; }
    footer.small { font-size: 11px; color: #64748b; margin-top: 10px; }
    input[type="file"] { display: none; }
    .toggle { display: inline-flex; align-items: center; gap: 6px; }
    .field { display:flex; align-items:center; gap:8px; font-size:12px; }
    .field input[type="range"]{ width:160px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:6px; }
    .numrow{ display:grid; grid-template-columns: auto 1fr; gap:6px; align-items:center; }
    .numrow input{ width:100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; font-size:12px; }
    .select{ width:100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; font-size:12px; background:#fff; }
    .smallnote{ font-size:11px; color:#64748b; }
  </style>
  <!-- three.js r147 UMD & helpers -->
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/TransformControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/DragControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
  <div id="app">
    <header>
      <h1>시각 예술 시뮬레이터</h1>
      <span class="pill">three.js r147</span>
      <span class="muted">Orbit · Transform · DragControls</span>
    </header>

    <aside>
      <div class="panel stack">
        <h2>1) 구성요소 추가 (팔레트)</h2>
        <div class="row">
          <button class="btn" data-primitive="Box">박스</button>
          <button class="btn" data-primitive="Sphere">구</button>
          <button class="btn" data-primitive="Cylinder">원기둥</button>
          <button class="btn" data-primitive="Plane">바닥(Plane)</button>
        </div>
        <div class="row">
          <label class="btn" for="gltfFile">GLTF/GLB 불러오기</label>
          <input id="gltfFile" type="file" accept=".gltf,.glb" />
        </div>
        <div class="tip">
          개체를 클릭하면 <b>변형기(TransformControls)</b>가 붙습니다. <span class="kbd">W</span>/<span class="kbd">E</span>/<span class="kbd">R</span> 이동/회전/스케일, <span class="kbd">Q</span> 축모드, <span class="kbd">Delete</span> 삭제.
        </div>

        <h2>보조도구</h2>
        <div class="row">
          <label class="toggle"><input id="toggleGrid" type="checkbox" checked /> 그리드</label>
          <label class="toggle"><input id="toggleAxes" type="checkbox" checked /> 축</label>
          <label class="toggle"><input id="toggleSnap" type="checkbox" /> 스냅(1단위)</label>
          <label class="toggle"><input id="toggleDrag" type="checkbox" /> 드래그 이동 모드</label>
        </div>

        <h2>조명 & 환경</h2>
        <div class="row">
          <label class="toggle"><input id="toggleDir" type="checkbox" checked /> 직사광(키라이트)</label>
          <label class="toggle"><input id="toggleHemi" type="checkbox" checked /> 헤미라이트</label>
          <label class="toggle"><input id="toggleIBL" type="checkbox" /> 환경맵(IBL)</label>
          <label class="toggle"><input id="toggleSpot" type="checkbox" checked /> 스팟라이트</label>
          <label class="toggle"><input id="toggleRim" type="checkbox" checked /> 림 라이트</label>
          <label class="toggle"><input id="togglePoint" type="checkbox" checked /> 포인트(회전)</label>
        </div>
        <div class="field">
          <span>노출</span>
          <input id="exposure" type="range" min="0.3" max="2.2" step="0.05" value="1.0" />
          <span id="exposureVal" class="muted">1.0</span>
        </div>

        <!-- 조명 편집 -->
        <h2>조명 편집</h2>
        <div class="stack">
          <select id="lightPick" class="select">
            <option value="dir">Directional (키)</option>
            <option value="spot">Spot</option>
            <option value="rim">Directional (림)</option>
            <option value="point">Point</option>
          </select>
          <label class="toggle"><input id="editTarget" type="checkbox" /> 타겟 편집(Spot/Directional)</label>

          <div class="grid2">
            <div class="numrow"><span>X</span><input id="lx" type="number" step="0.1"></div>
            <div class="numrow"><span>Y</span><input id="ly" type="number" step="0.1"></div>
            <div class="numrow"><span>Z</span><input id="lz" type="number" step="0.1"></div>
            <button id="focusLight" class="btn">카메라 포커스</button>
          </div>

          <div class="grid2">
            <div class="numrow"><span>강도</span><input id="lint" type="number" step="0.1" min="0" value="1.0"></div>
            <div class="numrow" id="spotOnly"><span>스팟 각도(°)</span><input id="langle" type="number" step="1" min="5" max="80" value="35"></div>
          </div>
          <div class="smallnote">라이트 선택 후 값을 바꾸거나, 장면에서 기즈모로 직접 드래그하세요.</div>
        </div>

        <!-- 스팟 쿠키(패턴) -->
        <h2>스팟 쿠키(패턴)</h2>
        <div class="stack">
          <label class="toggle"><input id="cookieOn" type="checkbox" checked /> 쿠키 사용</label>
          <div class="grid2">
            <div class="numrow">
              <span>패턴</span>
              <select id="cookieType" class="select">
                <option value="circle">동그라미</option>
                <option value="ring">도넛(링)</option>
                <option value="stripes">줄무늬</option>
                <option value="image">이미지</option>
              </select>
            </div>
            <div class="numrow"><span>회전(°)</span><input id="cookieRot" type="number" step="1" value="0"></div>
            <div class="numrow"><span>부드러움</span><input id="cookieSoft" type="number" step="0.05" value="0.35" min="0" max="0.95"></div>
            <div class="numrow" id="cookieRingRow"><span>내부반경</span><input id="cookieInner" type="number" step="0.05" value="0.4" min="0" max="0.95"></div>
            <div class="numrow" id="cookieStripeRow"><span>줄 개수</span><input id="cookieStripes" type="number" step="1" value="6" min="2" max="64"></div>
            <div class="numrow"><span>반전</span><input id="cookieInvert" type="checkbox"></div>
          </div>
          <div class="row">
            <label class="btn" for="cookieImg">이미지 선택</label>
            <input id="cookieImg" type="file" accept="image/*">
            <button id="cookieReset" class="btn">기본(동그라미)</button>
          </div>
          <div class="smallnote">밝은 부분이 비추는 영역입니다. (쿠키=스팟 프로젝션 마스크)</div>
        </div>

        <!-- 조명 시각화 -->
        <h2>조명 시각화</h2>
        <div class="row">
          <label class="toggle"><input id="visHelpers" type="checkbox" checked /> 라이트 헬퍼</label>
          <label class="toggle"><input id="visBeams" type="checkbox" checked /> 빔/타겟 라인</label>
          <label class="toggle"><input id="visSpotFoot" type="checkbox" checked /> 스팟 투영 원</label>
          <label class="toggle"><input id="visDirFrustum" type="checkbox" /> 키 그림자 영역</label>
        </div>

        <h2>배치 유틸</h2>
        <div class="row">
          <button id="layoutLine" class="btn">제작순서로 가로 정렬</button>
          <button id="focusSel" class="btn">선택 개체 보기</button>
        </div>
        <footer class="small">클릭 선택 · 드래그 이동(모드 ON) · 휠 줌 · 우클릭 드래그 회전</footer>
      </div>
    </aside>

    <main id="viewport">
      <div id="canvasWrap"></div>
    </main>

    <aside class="right">
      <div class="panel stack">
        <h2>2) 제작 순서</h2>
        <div id="sequence" class="list"></div>
        <div class="row">
          <button id="exportJson" class="btn">장면 내보내기(JSON)</button>
          <label class="btn" for="importJson">가져오기(JSON)</label>
          <input id="importJson" type="file" accept=".json" />
        </div>
        <div class="tip">순서대로 X축에 자동 배치하려면 “제작순서로 가로 정렬”을 누르세요.</div>
        <h2>선택 정보</h2>
        <div id="selInfo" class="muted">선택된 개체가 없습니다.</div>
        <h2>단축키</h2>
        <div class="tip">
          <p><span class="kbd">W</span>/<span class="kbd">E</span>/<span class="kbd">R</span>: 이동/회전/스케일 · <span class="kbd">Q</span>: 축 모드 토글(로컬/월드)</p>
          <p><span class="kbd">Delete</span>: 삭제 · <span class="kbd">Esc</span>: 선택 해제</p>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // === 기본 three.js 세팅 ===
    const WRAP = document.getElementById('canvasWrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    WRAP.appendChild(renderer.domElement);

    function fitRenderer(){
      const w = WRAP.clientWidth || window.innerWidth;
      const h = WRAP.clientHeight || (window.innerHeight - 60);
      renderer.setSize(w, h); camera.aspect = w/h; camera.updateProjectionMatrix();
    }

    const scene = new THREE.Scene();
    const DEFAULT_BG = new THREE.Color(0xf8fafc); // 기본 배경색
    scene.background = DEFAULT_BG;

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
    camera.position.set(6, 6, 12);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ===== 라이트 =====
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334155, 0.5);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,10,7);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 50;
    dir.shadow.radius = 2.5;
    scene.add(dir);

    const spot = new THREE.SpotLight(0xffffff, 1.1, 40, THREE.MathUtils.degToRad(35), 0.35, 1.5);
    spot.position.set(6, 9, 3);
    spot.target.position.set(0, 0, 0);
    spot.castShadow = true;
    spot.shadow.mapSize.set(1024,1024);
    scene.add(spot, spot.target);

    const rim = new THREE.DirectionalLight(0x9ecfff, 0.6);
    rim.position.set(-6, 4, -6);
    scene.add(rim);

    const point = new THREE.PointLight(0xfff2cc, 0.8, 30, 2.0);
    point.position.set(0, 3, 6);
    point.castShadow = true;
    scene.add(point);

    const pointViz = new THREE.Mesh(
      new THREE.SphereGeometry(0.07, 16, 12),
      new THREE.MeshBasicMaterial({ color: 0xffc107 })
    );
    point.add(pointViz);

    // ===== 그리드/축 =====
    const grid = new THREE.GridHelper(50, 50, 0x94a3b8, 0xcbd5e1);
    scene.add(grid);
    const axes = new THREE.AxesHelper(2);
    scene.add(axes);

    // ===== 컨트롤러/로더 =====
    const tctrl = new THREE.TransformControls(camera, renderer.domElement);
    tctrl.addEventListener('dragging-changed', (e)=>{ controls.enabled = !e.value; });
    scene.add(tctrl);

    const loader = new THREE.GLTFLoader();

    // ===== IBL(HDR) =====
    let iblTexture = null;
    const rgbeLoader = new THREE.RGBELoader();
    const pmrem = new THREE.PMREMGenerator(renderer);
    pmrem.compileEquirectangularShader();

    function enableIBL(on){
      if(on){
        if(iblTexture){
          scene.environment = iblTexture;
        } else {
          rgbeLoader.setDataType(THREE.UnsignedByteType)
            .load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr',
              (hdr)=>{
                iblTexture = pmrem.fromEquirectangular(hdr).texture;
                hdr.dispose && hdr.dispose();
                scene.environment = iblTexture;
                updateBlackout();
              },
              undefined,
              (err)=>{ console.warn('HDR 로드 실패:', err); }
            );
        }
      } else {
        scene.environment = null;
      }
    }

    // ===== 피킹/상태 =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let selected = null;           // 장면 오브젝트 선택
    let selectedLightObj = null;   // 라이트(또는 타겟) 편집용 선택
    let idCounter = 1; 
    const dragTargets = [];
    let dragControls = null;
    let dragging = false;

    const seqList = document.getElementById('sequence');
    const selInfo = document.getElementById('selInfo');

    // ===== 유틸 =====
    function addToScene(obj, label){
      obj.traverse?.(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
          if (o.material && o.material.isMeshStandardMaterial) {
            o.material.metalness ??= 0.1;
            o.material.roughness ??= 0.8;
          }
        }
      });
      obj.userData.__id = idCounter++;
      obj.userData.label = label || obj.type;
      obj.userData.step = seqList.children.length;
      scene.add(obj);
      dragTargets.push(obj);
      refreshDragControls();
      addToSequenceUI(obj);
      selectObject(obj);
    }

    function createPrimitive(kind){
      const primMat = new THREE.MeshStandardMaterial({ color: 0x64748b, metalness: 0.15, roughness: 0.55 });
      let mesh;
      if (kind === 'Box') mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), primMat);
      if (kind === 'Sphere') mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 16), primMat);
      if (kind === 'Cylinder') mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1, 24), primMat);
      if (kind === 'Plane') {
        mesh = new THREE.Mesh(
          new THREE.PlaneGeometry(12,12),
          new THREE.MeshStandardMaterial({ color: 0xe2e8f0, roughness: 0.95, metalness: 0.0, side: THREE.DoubleSide })
        );
        mesh.rotation.x = -Math.PI/2;
        mesh.receiveShadow = true;
      }
      mesh.position.set((Math.random()-0.5)*4, kind==='Plane'?0:0.5, (Math.random()-0.5)*4);
      addToScene(mesh, kind);
    }

    function addGLTF(file){
      const url = URL.createObjectURL(file);
      loader.load(url, (gltf)=>{
        const root = gltf.scene; root.position.set((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3);
        addToScene(root, file.name.replace(/\.(gltf|glb)$/i,'')); URL.revokeObjectURL(url);
      }, undefined, (err)=>{ alert('GLTF 로드 실패: '+err.message); });
    }

    function findObjectById(id){ return scene.children.find(o => o.userData && o.userData.__id === id) || null; }

    function selectObject(obj){
      selected = obj; tctrl.detach();
      selectedLightObj = null; // 라이트 편집 중지
      if (obj) { tctrl.attach(obj); updateSelInfo(); updateSequenceUI(); }
      else { selInfo.textContent = '선택된 개체가 없습니다.'; updateSequenceUI(); }
    }

    // ---- 라이트 편집: UI ----
    const lightPick = document.getElementById('lightPick');
    const editTarget = document.getElementById('editTarget');
    const liX = document.getElementById('lx');
    const liY = document.getElementById('ly');
    const liZ = document.getElementById('lz');
    const lInt = document.getElementById('lint');
    const lAngle = document.getElementById('langle');
    const spotOnly = document.getElementById('spotOnly');
    const focusLightBtn = document.getElementById('focusLight');

    function currentLight(){
      const key = lightPick.value;
      const light = (key==='dir')?dir : (key==='spot')?spot : (key==='rim')?rim : point;
      if (editTarget.checked && (key==='dir' || key==='spot')) {
        return light.target;
      }
      return light;
    }

    function syncLightUIFromObject(obj){
      const p = obj.position;
      liX.value = p.x.toFixed(2);
      liY.value = p.y.toFixed(2);
      liZ.value = p.z.toFixed(2);

      const key = lightPick.value;
      const light = (key==='dir')?dir : (key==='spot')?spot : (key==='rim')?rim : point;
      lInt.value = (light.intensity ?? 1).toFixed(2);
      spotOnly.style.display = (key==='spot') ? '' : 'none';
      if (key==='spot') {
        lAngle.value = Math.round(THREE.MathUtils.radToDeg(spot.angle));
      }
    }

    function attachLightTransform(obj){
      selected = null; updateSequenceUI();
      tctrl.detach();
      tctrl.attach(obj);
      selectedLightObj = obj;
      updateSelInfo();
    }

    function updateLightFromInputs(){
      const obj = currentLight();
      const nx = parseFloat(liX.value)||0;
      const ny = parseFloat(liY.value)||0;
      const nz = parseFloat(liZ.value)||0;
      obj.position.set(nx, ny, nz);
      const key = lightPick.value;
      const light = (key==='dir')?dir : (key==='spot')?spot : (key==='rim')?rim : point;
      light.intensity = Math.max(0, parseFloat(lInt.value)||0);
      if (key==='spot') {
        const deg = Math.min(80, Math.max(5, parseFloat(lAngle.value)||35));
        spot.angle = THREE.MathUtils.degToRad(deg);
      }
      if (obj === spot.target || obj === dir.target) {
        obj.updateMatrixWorld();
      }
    }

    function focusCameraTo(obj){
      controls.target.copy(obj.position);
      camera.position.set(obj.position.x + 6, obj.position.y + 6, obj.position.z + 12);
    }

    lightPick.addEventListener('change', ()=>{
      const obj = currentLight();
      attachLightTransform(obj);
      syncLightUIFromObject(obj);
    });
    editTarget.addEventListener('change', ()=>{
      const obj = currentLight();
      attachLightTransform(obj);
      syncLightUIFromObject(obj);
    });

    [liX, liY, liZ, lInt, lAngle].forEach(el=>{
      el.addEventListener('input', updateLightFromInputs);
      el.addEventListener('change', updateLightFromInputs);
    });

    focusLightBtn.addEventListener('click', ()=>{
      focusCameraTo(currentLight());
    });

    tctrl.addEventListener('change', ()=>{
      if (selectedLightObj) {
        syncLightUIFromObject(selectedLightObj);
      }
      updateSelInfo();
    });

    // ---- 선택 정보 표시 ----
    function updateSelInfo(){
      if (selectedLightObj) {
        const p=selectedLightObj.position;
        const who = (selectedLightObj===spot.target||selectedLightObj===dir.target)? 'Light Target' : 'Light';
        selInfo.innerHTML = `<div><b>${who}</b> (${lightPick.value}${selectedLightObj===spot.target?' target':''}${selectedLightObj===dir.target?' target':''})</div>
          <div>pos: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}</div>
          <div class="muted">W/E/R 이동·회전·스케일, Q 축모드</div>`;
        return;
      }
      if (!selected) return;
      const p=selected.position, r=selected.rotation, s=selected.scale;
      selInfo.innerHTML = `<div><b>${selected.userData.label}</b> (#${selected.userData.__id})</div>
      <div class="muted">step: ${selected.userData.step}</div>
      <div>pos: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}</div>
      <div>rot: ${(THREE.MathUtils.radToDeg(r.x)).toFixed(1)}, ${(THREE.MathUtils.radToDeg(r.y)).toFixed(1)}, ${(THREE.MathUtils.radToDeg(r.z)).toFixed(1)}</div>
      <div>scl: ${s.x.toFixed(2)}, ${s.y.toFixed(2)}, ${s.z.toFixed(2)}</div>`;
    }

    function addToSequenceUI(obj){
      const el = document.createElement('div'); el.className='item'; el.dataset.id = obj.userData.__id;
      el.innerHTML = `<div><div class="title">${obj.userData.label}</div><div class="sub">#${obj.userData.__id}</div></div>
      <div class="row"><button class="btn up">▲</button><button class="btn down">▼</button><button class="btn del danger">삭제</button></div>`;
      el.addEventListener('click',(e)=>{ if (!e.target.classList.contains('btn')){ const target=findObjectById(obj.userData.__id); if (target) selectObject(target);} });
      el.querySelector('.up').addEventListener('click',(e)=>{ e.stopPropagation(); moveStep(obj,-1); });
      el.querySelector('.down').addEventListener('click',(e)=>{ e.stopPropagation(); moveStep(obj,+1); });
      el.querySelector('.del').addEventListener('click',(e)=>{ e.stopPropagation(); deleteObject(obj); });
      seqList.appendChild(el); renumberSteps();
    }

    function moveStep(obj, delta){
      const items=[...seqList.children]; const idx=items.findIndex(el=>+el.dataset.id===obj.userData.__id);
      const newIdx=Math.max(0, Math.min(items.length-1, idx+delta));
      if (newIdx!==idx){ seqList.insertBefore(items[idx], items[delta>0 ? newIdx.nextSibling : newIdx]); renumberSteps(); updateSequenceUI(); }
    }

    function renumberSteps(){ [...seqList.children].forEach((el,i)=>{ const id=+el.dataset.id; const obj=findObjectById(id); if (obj) obj.userData.step=i; }); }

    function updateSequenceUI(){ const items=[...seqList.children]; items.forEach(el=>el.classList.remove('ghost')); if (selected){ const el=items.find(e=>+e.dataset.id===selected.userData.__id); el?.classList.add('ghost'); } }

    function deleteObject(obj){ if (selected && selected.userData.__id===obj.userData.__id){ tctrl.detach(); selected=null; selInfo.textContent='선택된 개체가 없습니다.'; }
      scene.remove(obj); const el=[...seqList.children].find(e=>+e.dataset.id===obj.userData.__id); el?.remove();
      const idx = dragTargets.indexOf(obj); if (idx>-1) dragTargets.splice(idx,1); refreshDragControls(); renumberSteps(); }

    function layoutByStep(){ const items=[...seqList.children]; const gap=2.2; items.forEach((el,i)=>{ const obj=findObjectById(+el.dataset.id); if (obj) obj.position.x=i*gap; }); camera.position.set(items.length*1.2, items.length*0.4+5, items.length*2.2+8); }

    function exportJSON(){ const data=scene.children.filter(o=>o.userData && o.userData.__id).map(o=>({ id:o.userData.__id,label:o.userData.label,step:o.userData.step,type:o.type,position:o.position.toArray(),rotation:[o.rotation.x,o.rotation.y,o.rotation.z],scale:o.scale.toArray() })).sort((a,b)=>a.step-b.step);
      const blob=new Blob([JSON.stringify({version:1,items:data},null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='scene.json'; a.click(); URL.revokeObjectURL(a.href); }

    function importJSON(file){ const reader=new FileReader(); reader.onload=()=>{ try{ const parsed=JSON.parse(reader.result); [...scene.children].filter(o=>o.userData && o.userData.__id).forEach(o=>scene.remove(o)); seqList.innerHTML=''; dragTargets.length=0; refreshDragControls(); for(const it of parsed.items){ let obj; if (it.type.includes('Mesh')){ obj=new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x64748b})); } else { obj=new THREE.Object3D(); }
        obj.position.fromArray(it.position); obj.rotation.set(it.rotation[0],it.rotation[1],it.rotation[2]); obj.scale.fromArray(it.scale); addToScene(obj,it.label); } renumberSteps(); } catch(e){ alert('JSON 파싱 실패: '+e.message); } }; reader.readAsText(file); }

    // DragControls on/off
    const toggleDrag = document.getElementById('toggleDrag');
    function refreshDragControls(){ if (dragControls){ dragControls.deactivate(); dragControls.dispose(); dragControls=null; }
      if (toggleDrag?.checked && dragTargets.length){ dragControls = new THREE.DragControls(dragTargets, camera, renderer.domElement);
        dragControls.addEventListener('dragstart', ()=>{ dragging=true; controls.enabled=false; tctrl.detach(); });
        dragControls.addEventListener('drag', ()=>{ /* noop */ });
        dragControls.addEventListener('dragend', ()=>{ dragging=false; controls.enabled=true; });
      }
    }

    // ===== 블랙아웃 판정 & 적용 =====
    function isAllLightsOff() {
      const iblOff   = !document.getElementById('toggleIBL').checked || scene.environment === null;
      const dirOff   = !document.getElementById('toggleDir').checked || !dir.visible;
      const hemiOff  = !document.getElementById('toggleHemi').checked || !hemi.visible;
      const spotOff  = !document.getElementById('toggleSpot').checked || !spot.visible;
      const rimOff   = !document.getElementById('toggleRim').checked || !rim.visible;
      const pointOff = !document.getElementById('togglePoint').checked || !point.visible;
      return iblOff && dirOff && hemiOff && spotOff && rimOff && pointOff;
    }

    function updateBlackout() {
      if (isAllLightsOff()) {
        scene.background = new THREE.Color(0x000000);
        grid.visible = false;
        axes.visible = false;
      } else {
        scene.background = DEFAULT_BG;
        grid.visible = document.getElementById('toggleGrid').checked;
        axes.visible = document.getElementById('toggleAxes').checked;
      }
    }

    // =========================
    // 조명 "방향/발원" 시각화
    // =========================
    // 헬퍼들
    const dirHelper  = new THREE.DirectionalLightHelper(dir, 1, 0x38bdf8);
    const rimHelper  = new THREE.DirectionalLightHelper(rim, 1, 0xf43f5e);
    const spotHelper = new THREE.SpotLightHelper(spot, 0x22c55e);
    const pointHelper= new THREE.PointLightHelper(point, 0.2, 0xffc107);
    const dirCamHelper = new THREE.CameraHelper(dir.shadow.camera);

    // 빔/타겟 라인
    function makeLine(color){
      const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
      const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.85 });
      const line = new THREE.Line(geo, mat);
      return line;
    }
    const dirLine  = makeLine(0x38bdf8);
    const rimLine  = makeLine(0xf43f5e);
    const spotLine = makeLine(0x22c55e);

    // 스팟 투영 원(지면 y=0)
    const spotFoot = new THREE.LineLoop(
      new THREE.CircleGeometry(1, 64),
      new THREE.LineBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.65 })
    );
    spotFoot.rotation.x = -Math.PI/2; // XZ평면
    spotFoot.visible = false;

    // 도우미 마킹(피킹 무시용)
    function markHelper(obj){ obj.traverse?.(o=>{ o.userData.__helper = true; }); }
    [dirHelper, rimHelper, spotHelper, pointHelper, dirCamHelper, dirLine, rimLine, spotLine, spotFoot].forEach(o=>{
      markHelper(o); scene.add(o);
    });

    // UI 토글
    const visHelpers    = document.getElementById('visHelpers');
    const visBeams      = document.getElementById('visBeams');
    const visSpotFoot   = document.getElementById('visSpotFoot');
    const visDirFrustum = document.getElementById('visDirFrustum');

    visHelpers.addEventListener('change', ()=>updateVisualizers(true));
    visBeams.addEventListener('change',   ()=>updateVisualizers(true));
    visSpotFoot.addEventListener('change',()=>updateVisualizers(true));
    visDirFrustum.addEventListener('change',()=>updateVisualizers(true));

    function setLineEnds(line, a, b){
      const pos = line.geometry.attributes.position;
      pos.setXYZ(0, a.x, a.y, a.z);
      pos.setXYZ(1, b.x, b.y, b.z);
      pos.needsUpdate = true;
      line.visible = true;
    }

    function groundIntersection(origin, dirNorm){
      // 평면 y=0 과 교차 (t = -origin.y / dir.y)
      if (Math.abs(dirNorm.y) < 1e-5) return null;
      const t = -origin.y / dirNorm.y;
      if (t <= 0) return null;
      return origin.clone().add(dirNorm.clone().multiplyScalar(t)); // 교차점
    }

    function updateSpotFootprint(){
      if (!visSpotFoot.checked || !spot.visible) { spotFoot.visible = false; return; }
      const o = spot.getWorldPosition(new THREE.Vector3());
      const tgt = spot.target.getWorldPosition(new THREE.Vector3());
      const d = tgt.clone().sub(o).normalize();
      const hit = groundIntersection(o, d);
      if (!hit){ spotFoot.visible=false; return; }
      const dist = hit.distanceTo(o);
      const radius = Math.tan(spot.angle) * dist;
      spotFoot.position.copy(hit);
      spotFoot.scale.setScalar(Math.max(0.001, radius));
      spotFoot.visible = true;
    }

    function updateVisualizers(force=false){
      // 헬퍼 가시성
      const helpersOn = visHelpers.checked;
      dirHelper.visible   = helpersOn && dir.visible;
      rimHelper.visible   = helpersOn && rim.visible;
      spotHelper.visible  = helpersOn && spot.visible;
      pointHelper.visible = helpersOn && point.visible;

      dirCamHelper.visible = visDirFrustum.checked && dir.visible;

      // 헬퍼 갱신(스팟은 매 프레임 필요)
      spotHelper.update();
      dirHelper.update?.();
      rimHelper.update?.();

      // 빔/타겟 라인
      const beamsOn = visBeams.checked;
      dirLine.visible = rimLine.visible = spotLine.visible = false;
      if (beamsOn){
        if (dir.visible){
          setLineEnds(dirLine, dir.position, dir.target.getWorldPosition(new THREE.Vector3()));
        }
        if (rim.visible){
          setLineEnds(rimLine, rim.position, rim.target?.getWorldPosition(new THREE.Vector3()) ?? new THREE.Vector3(0,0,0));
        }
        if (spot.visible){
          // 스팟: 라인은 라이트 → 지면 교차(or 타겟)
          const o = spot.getWorldPosition(new THREE.Vector3());
          const tgt = spot.target.getWorldPosition(new THREE.Vector3());
          const d = tgt.clone().sub(o).normalize();
          const hit = groundIntersection(o, d);
          setLineEnds(spotLine, o, hit ?? tgt);
        }
      }

      // 스팟 투영 원
      updateSpotFootprint();
    }

    // ===== 이벤트 바인딩 =====
    document.getElementById('toggleGrid').addEventListener('change',(e)=>{ 
      if (!isAllLightsOff()) grid.visible = e.target.checked; 
    });
    document.getElementById('toggleAxes').addEventListener('change',(e)=>{ 
      if (!isAllLightsOff()) axes.visible = e.target.checked; 
    });
    document.getElementById('toggleSnap').addEventListener('change',(e)=>{ const on=e.target.checked; tctrl.setTranslationSnap(on?1:null); tctrl.setRotationSnap(on?THREE.MathUtils.degToRad(15):null); tctrl.setScaleSnap(on?0.1:null); });
    document.getElementById('toggleDrag').addEventListener('change', ()=>{ refreshDragControls(); });

    // 조명/환경 토글 + 노출
    document.getElementById('toggleDir').addEventListener('change', (e)=>{ dir.visible = e.target.checked; updateBlackout(); updateVisualizers(true); });
    document.getElementById('toggleHemi').addEventListener('change', (e)=>{ hemi.visible = e.target.checked; updateBlackout(); });
    document.getElementById('toggleIBL').addEventListener('change', (e)=> { enableIBL(e.target.checked); updateBlackout(); });
    document.getElementById('toggleSpot').addEventListener('change',   (e)=> { spot.visible = e.target.checked; updateBlackout(); updateVisualizers(true); });
    document.getElementById('toggleRim').addEventListener('change',    (e)=> { rim.visible = e.target.checked; updateBlackout(); updateVisualizers(true); });
    document.getElementById('togglePoint').addEventListener('change',  (e)=> { point.visible = e.target.checked; updateBlackout(); updateVisualizers(true); });

    const exposureEl = document.getElementById('exposure');
    const exposureVal = document.getElementById('exposureVal');
    exposureEl.addEventListener('input', (e)=> {
      renderer.toneMappingExposure = parseFloat(e.target.value);
      exposureVal.textContent = e.target.value;
    });

    document.querySelectorAll('[data-primitive]').forEach(btn=>btn.addEventListener('click', ()=>createPrimitive(btn.dataset.primitive)));
    document.getElementById('gltfFile').addEventListener('change',(e)=>{ const f=e.target.files[0]; if (f) addGLTF(f); e.target.value=''; });
    document.getElementById('importJson').addEventListener('change',(e)=>{ const f=e.target.files[0]; if (f) importJSON(f); e.target.value=''; });
    document.getElementById('exportJson').addEventListener('click', exportJSON);
    document.getElementById('layoutLine').addEventListener('click', layoutByStep);
    document.getElementById('focusSel').addEventListener('click', ()=>{ if(selected) controls.target.copy(selected.position); });

    // ===== 스팟 쿠키(고보) 생성/적용 =====
    const cookieState = { type:'circle', rotDeg:0, soft:0.35, inner:0.4, stripes:6, invert:false, img:null };
    const cookieCvs = document.createElement('canvas'); cookieCvs.width = cookieCvs.height = 512;
    const cookieCtx = cookieCvs.getContext('2d');
    function clearCookie(){ cookieCtx.clearRect(0,0,cookieCvs.width,cookieCvs.height); }
    function drawCircle(){ const s=cookieCvs.width, r=s*0.5, g=cookieCtx.createRadialGradient(r,r,0,r,r,r), e=Math.max(0,1-cookieState.soft); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(e,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); cookieCtx.fillStyle=g; cookieCtx.beginPath(); cookieCtx.arc(r,r,r,0,Math.PI*2); cookieCtx.fill(); }
    function drawRing(){ const s=cookieCvs.width, r=s*0.5, ir=Math.min(Math.max(cookieState.inner,0),0.95)*r; cookieCtx.save(); cookieCtx.translate(r,r); cookieCtx.rotate(cookieState.rotDeg*Math.PI/180); cookieCtx.translate(-r,-r); const g=cookieCtx.createRadialGradient(r,r,ir,r,r,r), e=Math.max(0,1-cookieState.soft); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(e,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); cookieCtx.fillStyle=g; cookieCtx.beginPath(); cookieCtx.arc(r,r,r,0,Math.PI*2); cookieCtx.fill(); cookieCtx.globalCompositeOperation='destination-out'; cookieCtx.beginPath(); cookieCtx.arc(r,r,ir*(1-cookieState.soft*0.8),0,Math.PI*2); cookieCtx.fill(); cookieCtx.globalCompositeOperation='source-over'; cookieCtx.restore(); }
    function drawStripes(){ const s=cookieCvs.width, r=s*0.5, n=Math.max(2,Math.min(64,Math.floor(cookieState.stripes))); cookieCtx.save(); cookieCtx.translate(r,r); cookieCtx.rotate(cookieState.rotDeg*Math.PI/180); cookieCtx.translate(-r,-r); drawCircle(); cookieCtx.globalCompositeOperation='destination-out'; const w=s/n/2; cookieCtx.fillStyle='rgba(0,0,0,1)'; for(let i=0;i<n;i++){ const x=(i*(s/n))+w*0.5; cookieCtx.fillRect(x,0,w,s);} cookieCtx.globalCompositeOperation='source-over'; cookieCtx.restore(); }
    function drawImageCookie(){ const s=cookieCvs.width, r=s*0.5, img=cookieState.img; if(!img){ drawCircle(); return; } cookieCtx.save(); cookieCtx.translate(r,r); cookieCtx.rotate(cookieState.rotDeg*Math.PI/180); cookieCtx.translate(-r,-r); const ar=img.width/img.height; let dw=s, dh=s; if(ar>1){ dh=s; dw=s*ar;} else { dw=s; dh=s/ar;} const dx=(s-dw)/2, dy=(s-dh)/2; cookieCtx.drawImage(img,dx,dy,dw,dh); const im=cookieCtx.getImageData(0,0,s,s), data=im.data; for(let i=0;i<data.length;i+=4){ const rr=data[i],gg=data[i+1],bb=data[i+2],aa=data[i+3]/255; let lum=(0.299*rr+0.587*gg+0.114*bb)/255; if(cookieState.invert) lum=1-lum; data[i]=data[i+1]=data[i+2]=Math.round(lum*255); data[i+3]=Math.round(aa*255);} cookieCtx.putImageData(im,0,0); cookieCtx.globalCompositeOperation='destination-in'; const g=cookieCtx.createRadialGradient(r,r,0,r,r,r), e=Math.max(0,1-cookieState.soft); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(e,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); cookieCtx.fillStyle=g; cookieCtx.beginPath(); cookieCtx.arc(r,r,r,0,Math.PI*2); cookieCtx.fill(); cookieCtx.globalCompositeOperation='source-over'; cookieCtx.restore(); }
    function buildCookieTexture(){ clearCookie(); if(cookieState.type==='circle') drawCircle(); else if(cookieState.type==='ring') drawRing(); else if(cookieState.type==='stripes') drawStripes(); else if(cookieState.type==='image') drawImageCookie(); const tex=new THREE.CanvasTexture(cookieCvs); tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||1; tex.needsUpdate=true; return tex; }
    function applyCookie(){ if(!document.getElementById('cookieOn').checked){ if(spot.map){ spot.map.dispose(); spot.map=null; } return; } const t=buildCookieTexture(); if(spot.map) spot.map.dispose(); spot.map=t; spot.penumbra=Math.min(0.9, Math.max(0.0, cookieState.soft+0.25)); }
    const elCookieOn=document.getElementById('cookieOn'), elCookieType=document.getElementById('cookieType'), elCookieRot=document.getElementById('cookieRot'), elCookieSoft=document.getElementById('cookieSoft'), elCookieInner=document.getElementById('cookieInner'), elCookieStripes=document.getElementById('cookieStripes'), elCookieInvert=document.getElementById('cookieInvert'), elCookieImg=document.getElementById('cookieImg'), elCookieReset=document.getElementById('cookieReset'), rowRing=document.getElementById('cookieRingRow'), rowStripe=document.getElementById('cookieStripeRow');
    function refreshCookieRows(){ const t=elCookieType.value; rowRing.style.display=(t==='ring')?'':'none'; rowStripe.style.display=(t==='stripes')?'':'none'; }
    elCookieOn.addEventListener('change', applyCookie);
    elCookieType.addEventListener('change', ()=>{ cookieState.type=elCookieType.value; refreshCookieRows(); applyCookie(); });
    elCookieRot.addEventListener('input', ()=>{ cookieState.rotDeg=parseFloat(elCookieRot.value)||0; applyCookie(); });
    elCookieSoft.addEventListener('input', ()=>{ cookieState.soft=Math.min(0.95,Math.max(0,parseFloat(elCookieSoft.value)||0)); applyCookie(); });
    elCookieInner.addEventListener('input', ()=>{ cookieState.inner=Math.min(0.95,Math.max(0,parseFloat(elCookieInner.value)||0.4)); applyCookie(); });
    elCookieStripes.addEventListener('input', ()=>{ cookieState.stripes=Math.max(2,Math.min(64,parseInt(elCookieStripes.value,10)||6)); applyCookie(); });
    elCookieInvert.addEventListener('change', ()=>{ cookieState.invert=elCookieInvert.checked; applyCookie(); });
    elCookieImg.addEventListener('change', (e)=>{ const f=e.target.files?.[0]; if(!f) return; const img=new Image(); img.onload=()=>{ cookieState.img=img; cookieState.type='image'; elCookieType.value='image'; refreshCookieRows(); applyCookie(); }; img.src=URL.createObjectURL(f); });
    elCookieReset.addEventListener('click', ()=>{ cookieState.type='circle'; elCookieType.value='circle'; elCookieRot.value=0; cookieState.rotDeg=0; elCookieSoft.value=0.35; cookieState.soft=0.35; elCookieInvert.checked=false; cookieState.invert=false; refreshCookieRows(); applyCookie(); });

    // ===== 이벤트 바인딩(계속) =====
    // 마우스 피킹: 헬퍼 오브젝트는 무시
    function isHelperObject(obj){ let p=obj; while(p){ if(p.userData?.__helper) return true; p=p.parent; } return false; }
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      if (selectedLightObj) return;
      if (toggleDrag.checked) return; if (dragging) return;
      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-rect.left)/rect.width)*2-1; mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse, camera);
      const intersects=raycaster.intersectObjects(scene.children,true);
      const hit = intersects.find(h=> h.object && !isHelperObject(h.object) && h.object.parent!==tctrl);
      if (hit){ let root=hit.object; while(root.parent && !root.userData?.__id) root=root.parent; if (root.userData?.__id) selectObject(root); }
      else { selectObject(null); }
    });

    // 키 입력
    window.addEventListener('keydown',(e)=>{
      if (e.code==='Delete' && selected){ deleteObject(selected); }
      if (e.key==='w'||e.key==='W') tctrl.setMode('translate');
      if (e.key==='e'||e.key==='E') tctrl.setMode('rotate');
      if (e.key==='r'||e.key==='R') tctrl.setMode('scale');
      if (e.key==='q'||e.key==='Q') tctrl.setSpace(tctrl.space==='world'?'local':'world');
      if (e.key==='Escape'){
        tctrl.detach();
        if (selectedLightObj){ selectedLightObj=null; }
        selected=null; selInfo.textContent='선택된 개체가 없습니다.'; updateSequenceUI();
      }
    });

    // 리사이즈 & 초기화
    window.addEventListener('resize', fitRenderer);
    fitRenderer();

    // 시작 바닥
    createPrimitive('Plane');

    // 애니메이션 루프
    let time = 0;
    renderer.setAnimationLoop(()=>{
      controls.update();
      time += 0.01;
      const r = 6;
      point.position.set(Math.cos(time)*r, 3 + Math.sin(time*0.8)*0.5, Math.sin(time)*r);

      if (selectedLightObj) syncLightUIFromObject(selectedLightObj);
      updateSelInfo();
      updateBlackout();
      updateVisualizers();
      renderer.render(scene, camera);
    });

    // 초기: 라이트 UI 동기화 & 쿠키 적용 & 시각화 갱신
    (function initLightUI(){ const obj = currentLight(); attachLightTransform(obj); syncLightUIFromObject(obj); })();
    (function initCookie(){ refreshCookieRows(); applyCookie(); })();
    updateVisualizers(true);
    updateBlackout();
  </script>
</body>
</html>
