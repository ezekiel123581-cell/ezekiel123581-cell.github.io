<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>시각 예술 구성/제작순서 시뮬레이터 - three.js (r147)</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 280px 1fr 320px; grid-template-rows: 48px 1fr; height: 100vh; }
    header { grid-column: 1 / 4; display: flex; align-items: center; gap: 12px; padding: 8px 12px; border-bottom: 1px solid #e5e7eb; background: #fafafa; }
    header h1 { font-size: 16px; margin: 0; font-weight: 700; }
    .pill { padding: 4px 10px; border: 1px solid #e5e7eb; border-radius: 999px; background: #fff; font-size: 12px; }
    aside { border-right: 1px solid #e5e7eb; overflow: auto; }
    .right { border-left: 1px solid #e5e7eb; overflow: auto; }
    .panel { padding: 12px; }
    .panel h2 { font-size: 13px; margin: 10px 0; color: #111827; }
    .btn { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; background: white; cursor: pointer; font-size: 12px; }
    .btn:active { transform: translateY(1px); }
    .btn + .btn { margin-left: 6px; }
    .stack { display: flex; flex-direction: column; gap: 8px; }
    .row { display: flex; gap: 6px; flex-wrap: wrap; }
    .muted { color: #6b7280; font-size: 12px; }
    .list { display: grid; gap: 8px; }
    .item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; display: grid; grid-template-columns: 1fr auto; align-items: center; background: #fff; }
    .item .title { font-size: 13px; font-weight: 600; }
    .item .sub { font-size: 11px; color: #6b7280; }
    .ghost { opacity: .5; }
    #viewport { position: relative; background: #f8fafc; height: 100%; }
    #canvasWrap { width: 100%; height: 100%; position: absolute; inset: 0; }
    .tip { background: #f1f5f9; border: 1px dashed #cbd5e1; padding: 8px; border-radius: 8px; font-size: 12px; line-height: 1.4; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 0 6px; border: 1px solid #e5e7eb; border-bottom-width: 2px; border-radius: 6px; background: #fff; }
    .danger { color: #b91c1c; }
    footer.small { font-size: 11px; color: #64748b; margin-top: 10px; }
    input[type="file"] { display: none; }
    .toggle { display: inline-flex; align-items: center; gap: 6px; }
  </style>
  <!-- three.js r147 UMD & helpers -->
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/TransformControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/controls/DragControls.js"></script>
  <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="app">
    <header>
      <h1>시각 예술 시뮬레이터</h1>
      <span class="pill">three.js r147</span>
      <span class="muted">Orbit · Transform · DragControls</span>
    </header>

    <aside>
      <div class="panel stack">
        <h2>1) 구성요소 추가 (팔레트)</h2>
        <div class="row">
          <button class="btn" data-primitive="Box">박스</button>
          <button class="btn" data-primitive="Sphere">구</button>
          <button class="btn" data-primitive="Cylinder">원기둥</button>
          <button class="btn" data-primitive="Plane">바닥(Plane)</button>
        </div>
        <div class="row">
          <label class="btn" for="gltfFile">GLTF/GLB 불러오기</label>
          <input id="gltfFile" type="file" accept=".gltf,.glb" />
        </div>
        <div class="tip">
          개체를 클릭하면 <b>변형기(TransformControls)</b>가 붙습니다. <span class="kbd">W</span>/<span class="kbd">E</span>/<span class="kbd">R</span> 이동/회전/스케일, <span class="kbd">Delete</span> 삭제.
        </div>

        <h2>보조도구</h2>
        <div class="row">
          <label class="toggle"><input id="toggleGrid" type="checkbox" checked /> 그리드</label>
          <label class="toggle"><input id="toggleAxes" type="checkbox" checked /> 축</label>
          <label class="toggle"><input id="toggleSnap" type="checkbox" /> 스냅(1단위)</label>
          <label class="toggle"><input id="toggleDrag" type="checkbox" /> 드래그 이동 모드</label>
        </div>

        <h2>배치 유틸</h2>
        <div class="row">
          <button id="layoutLine" class="btn">제작순서로 가로 정렬</button>
          <button id="focusSel" class="btn">선택 개체 보기</button>
        </div>
        <footer class="small">클릭 선택 · 드래그 이동(모드 ON) · 휠 줌 · 우클릭 드래그 회전</footer>
      </div>
    </aside>

    <main id="viewport">
      <div id="canvasWrap"></div>
    </main>

    <aside class="right">
      <div class="panel stack">
        <h2>2) 제작 순서</h2>
        <div id="sequence" class="list"></div>
        <div class="row">
          <button id="exportJson" class="btn">장면 내보내기(JSON)</button>
          <label class="btn" for="importJson">가져오기(JSON)</label>
          <input id="importJson" type="file" accept=".json" />
        </div>
        <div class="tip">
          순서대로 X축에 자동 배치하려면 “제작순서로 가로 정렬”을 누르세요.
        </div>
        <h2>선택 정보</h2>
        <div id="selInfo" class="muted">선택된 개체가 없습니다.</div>
        <h2>단축키</h2>
        <div class="tip">
          <p><span class="kbd">W</span>/<span class="kbd">E</span>/<span class="kbd">R</span>: 이동/회전/스케일 · <span class="kbd">Q</span>: 축 모드 토글(로컬/월드)</p>
          <p><span class="kbd">Delete</span>: 삭제 · <span class="kbd">Esc</span>: 선택 해제</p>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // === 기본 three.js 세팅 ===
    const WRAP = document.getElementById('canvasWrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    WRAP.appendChild(renderer.domElement);
    function fitRenderer(){
      const w = WRAP.clientWidth || window.innerWidth;
      const h = WRAP.clientHeight || (window.innerHeight - 60);
      renderer.setSize(w, h); camera.aspect = w/h; camera.updateProjectionMatrix();
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
    camera.position.set(6, 6, 12);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 라이트
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334155, 0.6); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(5,10,7); dir.castShadow = true; scene.add(dir);

    // 그리드/축
    const grid = new THREE.GridHelper(50, 50, 0x94a3b8, 0xcbd5e1); scene.add(grid);
    const axes = new THREE.AxesHelper(2); scene.add(axes);

    // 컨트롤러
    const tctrl = new THREE.TransformControls(camera, renderer.domElement);
    tctrl.addEventListener('dragging-changed', (e)=>{ controls.enabled = !e.value; });
    scene.add(tctrl);

    // 로더
    const loader = new THREE.GLTFLoader();

    // 피킹
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // 상태
    let selected = null;
    let idCounter = 1; 
    const dragTargets = []; // 드래그 가능한 대상들
    let dragControls = null;
    let dragging = false;

    const paletteBtns = document.querySelectorAll('[data-primitive]');
    const seqList = document.getElementById('sequence');
    const selInfo = document.getElementById('selInfo');

    // === 유틸 ===
    function addToScene(obj, label){
      obj.traverse?.(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
      obj.userData.__id = idCounter++;
      obj.userData.label = label || obj.type;
      obj.userData.step = seqList.children.length;
      scene.add(obj);
      dragTargets.push(obj);
      refreshDragControls();
      addToSequenceUI(obj);
      selectObject(obj);
    }

    function createPrimitive(kind){
      let mesh; const mat = new THREE.MeshStandardMaterial({ color: 0x64748b, metalness: 0.1, roughness: 0.8 });
      if (kind === 'Box') mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
      if (kind === 'Sphere') mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 16), mat);
      if (kind === 'Cylinder') mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1, 24), mat);
      if (kind === 'Plane') { mesh = new THREE.Mesh(new THREE.PlaneGeometry(12,12), new THREE.MeshStandardMaterial({ color: 0xe2e8f0, side: THREE.DoubleSide })); mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true; }
      mesh.position.set((Math.random()-0.5)*4, kind==='Plane'?0:0.5, (Math.random()-0.5)*4);
      addToScene(mesh, kind);
    }

    function addGLTF(file){
      const url = URL.createObjectURL(file);
      loader.load(url, (gltf)=>{
        const root = gltf.scene; root.position.set((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3);
        addToScene(root, file.name.replace(/\.(gltf|glb)$/i,'')); URL.revokeObjectURL(url);
      }, undefined, (err)=>{ alert('GLTF 로드 실패: '+err.message); });
    }

    function selectObject(obj){
      selected = obj; tctrl.detach();
      if (obj) { tctrl.attach(obj); updateSelInfo(); updateSequenceUI(); }
      else { selInfo.textContent = '선택된 개체가 없습니다.'; updateSequenceUI(); }
    }

    function updateSelInfo(){
      if (!selected) return; const p=selected.position, r=selected.rotation, s=selected.scale;
      selInfo.innerHTML = `<div><b>${selected.userData.label}</b> (#${selected.userData.__id})</div>
      <div class="muted">step: ${selected.userData.step}</div>
      <div>pos: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}</div>
      <div>rot: ${(THREE.MathUtils.radToDeg(r.x)).toFixed(1)}, ${(THREE.MathUtils.radToDeg(r.y)).toFixed(1)}, ${(THREE.MathUtils.radToDeg(r.z)).toFixed(1)}</div>
      <div>scl: ${s.x.toFixed(2)}, ${s.y.toFixed(2)}, ${s.z.toFixed(2)}</div>`;
    }

    function addToSequenceUI(obj){
      const el = document.createElement('div'); el.className='item'; el.dataset.id = obj.userData.__id;
      el.innerHTML = `<div><div class="title">${obj.userData.label}</div><div class="sub">#${obj.userData.__id}</div></div>
      <div class="row"><button class="btn up">▲</button><button class="btn down">▼</button><button class="btn del danger">삭제</button></div>`;
      el.addEventListener('click',(e)=>{ if (!e.target.classList.contains('btn')){ const target=findObjectById(obj.userData.__id); if (target) selectObject(target);} });
      el.querySelector('.up').addEventListener('click',(e)=>{ e.stopPropagation(); moveStep(obj,-1); });
      el.querySelector('.down').addEventListener('click',(e)=>{ e.stopPropagation(); moveStep(obj,+1); });
      el.querySelector('.del').addEventListener('click',(e)=>{ e.stopPropagation(); deleteObject(obj); });
      seqList.appendChild(el); renumberSteps();
    }

    function findObjectById(id){ return scene.children.find(o => o.userData && o.userData.__id === id) || null; }

    function moveStep(obj, delta){
      const items=[...seqList.children]; const idx=items.findIndex(el=>+el.dataset.id===obj.userData.__id);
      const newIdx=Math.max(0, Math.min(items.length-1, idx+delta));
      if (newIdx!==idx){ seqList.insertBefore(items[idx], items[delta>0 ? newIdx.nextSibling : newIdx]); renumberSteps(); updateSequenceUI(); }
    }

    function renumberSteps(){ [...seqList.children].forEach((el,i)=>{ const id=+el.dataset.id; const obj=findObjectById(id); if (obj) obj.userData.step=i; }); }

    function updateSequenceUI(){ const items=[...seqList.children]; items.forEach(el=>el.classList.remove('ghost')); if (selected){ const el=items.find(e=>+e.dataset.id===selected.userData.__id); el?.classList.add('ghost'); } }

    function deleteObject(obj){ if (selected && selected.userData.__id===obj.userData.__id){ tctrl.detach(); selected=null; selInfo.textContent='선택된 개체가 없습니다.'; }
      scene.remove(obj); const el=[...seqList.children].find(e=>+e.dataset.id===obj.userData.__id); el?.remove();
      const idx = dragTargets.indexOf(obj); if (idx>-1) dragTargets.splice(idx,1); refreshDragControls(); renumberSteps(); }

    function layoutByStep(){ const items=[...seqList.children]; const gap=2.2; items.forEach((el,i)=>{ const obj=findObjectById(+el.dataset.id); if (obj) obj.position.x=i*gap; }); camera.position.set(items.length*1.2, items.length*0.4+5, items.length*2.2+8); }

    function exportJSON(){ const data=scene.children.filter(o=>o.userData && o.userData.__id).map(o=>({ id:o.userData.__id,label:o.userData.label,step:o.userData.step,type:o.type,position:o.position.toArray(),rotation:[o.rotation.x,o.rotation.y,o.rotation.z],scale:o.scale.toArray() })).sort((a,b)=>a.step-b.step);
      const blob=new Blob([JSON.stringify({version:1,items:data},null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='scene.json'; a.click(); URL.revokeObjectURL(a.href); }

    function importJSON(file){ const reader=new FileReader(); reader.onload=()=>{ try{ const parsed=JSON.parse(reader.result); [...scene.children].filter(o=>o.userData && o.userData.__id).forEach(o=>scene.remove(o)); seqList.innerHTML=''; dragTargets.length=0; refreshDragControls(); for(const it of parsed.items){ let obj; if (it.type.includes('Mesh')){ obj=new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x64748b})); } else { obj=new THREE.Object3D(); }
        obj.position.fromArray(it.position); obj.rotation.set(it.rotation[0],it.rotation[1],it.rotation[2]); obj.scale.fromArray(it.scale); addToScene(obj,it.label); } renumberSteps(); } catch(e){ alert('JSON 파싱 실패: '+e.message); } }; reader.readAsText(file); }

    // DragControls on/off
    const toggleDrag = document.getElementById('toggleDrag');
    function refreshDragControls(){ if (dragControls){ dragControls.deactivate(); dragControls.dispose(); dragControls=null; }
      if (toggleDrag?.checked && dragTargets.length){ dragControls = new THREE.DragControls(dragTargets, camera, renderer.domElement);
        dragControls.addEventListener('dragstart', ()=>{ dragging=true; controls.enabled=false; tctrl.detach(); });
        dragControls.addEventListener('drag', ()=>{ /* noop: position updates automatically */ });
        dragControls.addEventListener('dragend', ()=>{ dragging=false; controls.enabled=true; });
      }
    }

    // === 이벤트 바인딩 ===
    document.getElementById('toggleGrid').addEventListener('change',(e)=>{ grid.visible=e.target.checked; });
    document.getElementById('toggleAxes').addEventListener('change',(e)=>{ axes.visible=e.target.checked; });
    document.getElementById('toggleSnap').addEventListener('change',(e)=>{ const on=e.target.checked; tctrl.setTranslationSnap(on?1:null); tctrl.setRotationSnap(on?THREE.MathUtils.degToRad(15):null); tctrl.setScaleSnap(on?0.1:null); });
    document.getElementById('toggleDrag').addEventListener('change', ()=>{ refreshDragControls(); });

    const paletteBtnsEls = document.querySelectorAll('[data-primitive]');
    paletteBtnsEls.forEach(btn=>btn.addEventListener('click', ()=>createPrimitive(btn.dataset.primitive)));

    document.getElementById('gltfFile').addEventListener('change',(e)=>{ const f=e.target.files[0]; if (f) addGLTF(f); e.target.value=''; });
    document.getElementById('importJson').addEventListener('change',(e)=>{ const f=e.target.files[0]; if (f) importJSON(f); e.target.value=''; });
    document.getElementById('exportJson').addEventListener('click', exportJSON);
    document.getElementById('layoutLine').addEventListener('click', layoutByStep);
    document.getElementById('focusSel').addEventListener('click', ()=>{ if(selected) controls.target.copy(selected.position); });

    // 마우스 피킹 (드래그 중이거나 드래그 모드 ON이면 선택 클릭 비활성화)
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      if (toggleDrag.checked) return; if (dragging) return;
      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-rect.left)/rect.width)*2-1; mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse, camera);
      const intersects=raycaster.intersectObjects(scene.children,true);
      const first=intersects.find(hit=>hit.object && hit.object.parent!==tctrl);
      if (first){ let root=first.object; while(root.parent && !root.userData.__id) root=root.parent; if (root.userData.__id) selectObject(root); }
      else { selectObject(null); }
    });

    // 키 입력
    window.addEventListener('keydown',(e)=>{
      if (e.code==='Delete' && selected){ deleteObject(selected); }
      if (e.key==='w'||e.key==='W') tctrl.setMode('translate');
      if (e.key==='e'||e.key==='E') tctrl.setMode('rotate');
      if (e.key==='r'||e.key==='R') tctrl.setMode('scale');
      if (e.key==='q'||e.key==='Q') tctrl.setSpace(tctrl.space==='world'?'local':'world');
      if (e.key==='Escape'){ tctrl.detach(); selected=null; selInfo.textContent='선택된 개체가 없습니다.'; updateSequenceUI(); }
    });

    // 리사이즈 & 루프
    window.addEventListener('resize', ()=>{ fitRenderer(); });
    fitRenderer();

    // 시작 바닥 추가
    createPrimitive('Plane');

    renderer.setAnimationLoop(()=>{ controls.update(); updateSelInfo(); renderer.render(scene, camera); });
  </script>
</body>
</html>
